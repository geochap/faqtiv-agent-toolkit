import { Client } from "@opensearch-project/opensearch";

const opensearchConfig = {
  node: process.env.OPENSEARCH_URL,
};

const opensearch = process.env.OPENSEARCH_UR?new Client(opensearchConfig):null;

/**
 * Ensures the index exists with the given vector field and other field mappings.
 * 
 * @param {string} indexName - The name of the index
 * @param {string} vectorColumn - The name of the KNN vector field
 * @param {number} dimension - The dimensionality of the vector
 * @param {Object} otherColumns - An object with fieldName: fieldType pairs (e.g. { title: "text", year: "integer" })
 */
export async function ensureIndexExists(indexName, vectorColumn, dimension, otherColumns = {}) {
  const { body: exists } = await opensearch.indices.exists({ index: indexName });
  if (exists) return;

  const properties = {
    [vectorColumn]: {
      type: "knn_vector",
      dimension,
    },
  };

  for (const [name, type] of Object.entries(otherColumns)) {
    properties[name] = { type };
  }

  await opensearch.indices.create({
    index: indexName,
    body: {
      settings: {
        index: {
          knn: true,
        },
      },
      mappings: {
        properties,
      },
    },
  });
}

export async function knnQuery(indexName, vectorColumn, queryEmbedding, k, columns) {
  const searchResponse = await opensearch.search({
    index: indexName,
    body: {
      size: k,
      _source: columns, // Only retrieve the specified columns
      query: {
        bool: {
          must: {
            knn: {
              [vectorColumn]: {
                vector: queryEmbedding,
                k: k,
              },
            },
          },
        },
      },
    },
  });

  if (searchResponse.statusCode !== 200) {
    console.error('Error in search response:', searchResponse);
    throw new Error('Search failed');
  }

  return searchResponse.body.hits.hits.map((hit) => {
    const entry = {
      id: hit._id,
      score: hit._score,
    };
    for (const col of columns) {
      entry[col] = hit._source?.[col];
    }
    return entry;
  });
}

/**
 * Writes a single document to the OpenSearch index.
 *
 * @param {string} indexName - The name of the index
 * @param {string} id - Optional unique ID for the document (autogenerated if not provided)
 * @param {Object} doc - The full document to index (including knn vector and metadata fields)
 */
export async function writeToSearchIndex(indexName, id, doc) {
  const response = await opensearch.index({
    index: indexName,
    id, // may be undefined
    body: doc,
    refresh: true // ensures the doc is immediately searchable
  });

  if (response.statusCode !== 200 && response.statusCode !== 201) {
    console.error('‚ùå Failed to index document:', response.body);
    throw new Error('Indexing failed');
  }

  return response.body;
}

